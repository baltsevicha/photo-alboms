{"version":3,"sources":["components/Code/styles.module.css","components/Result/styles.module.css","components/Albom/styles.module.css","components/Previews/index.js","components/Result/getAlboms/calculateAlbom/sliceToRows.js","components/Result/getAlboms/calculateAlbom/analyze.js","components/Result/getAlboms/calculateAlbom/shuffle.js","components/Result/getAlboms/calculateAlbom/updateWidthHeight.js","components/Result/getAlboms/calculateAlbom/index.js","components/Result/index.js","components/Result/getAlboms/index.js","components/Result/getAlboms/chunk.js","components/Result/getAlboms/convertToRatio.js","components/Albom/index.jsx","components/Code/index.js","components/App/index.jsx","index.js","components/Previews/styles.module.css"],"names":["module","exports","Previews","photos","changeOrder","remove","map","photo","index","className","styles","container","src","image","preview","onClick","length","id","chunkByRows","list","size","result","startSliceIndex","Math","max","unshift","slice","ratio","sliceForTwoPhotos","sliceForThreePhotos","sumRowRation","sumRatio","rowsPhotos","rowsRatioDiff","push","diffSumRowsRatio","coeffForComparison","abs","calculateCoefficientForComparison","moveImageToPrevRow","maxDiffIndex","currentPhotosRow","firstPhotoOfNextRow","concat","moveImageToNextRow","prevPhotosRow","lastPhotoOfPrevRow","moveMethod","newRowsPhotos","row","moveImageToOtherLine","calculateMaxDiffIndex","updateSizes","rowPhotos","ratioSum","sum","firstPhoto","widthOfFirstPhoto","floor","heightOfFirstPhoto","updatedRowPhotos","width","height","sliceToRows","data","analyze","tmpData","shuffledRowsPhotos","shuffledData","shuffle","updateWidthHeight","Result","useState","setResult","useEffect","alboms","chunk","convertToRatio","albom","calculateAlbom","getAlboms","reduce","memo","item","removeExtraLayer","handleImage","file","Promise","resolve","reader","FileReader","onloadend","event","img","Image","onload","random","this","target","readAsDataURL","Albom","setPhotos","handleChange","a","files","requests","i","all","results","type","onChange","multiple","imagesContainer","prevIndex","newIndex","newPhotos","removeIndex","filter","Code","code","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.a025a5d1.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"styles_container__zQDVE\",\"data\":\"styles_data__ct4jE\",\"code\":\"styles_code__n3hbZ\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"albom\":\"styles_albom__2EzAS\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"styles_container__39iyr\",\"imagesContainer\":\"styles_imagesContainer__ot1b5\"};","import React from \"react\";\n\nimport styles from \"./styles.module.css\";\n\nconst Previews = ({ photos, changeOrder, remove }) => {\n  return (\n    <div>\n      {photos.map((photo, index) => {\n        return (\n          <div key={photo.id} className={styles.container}>\n            <img src={photo.image} className={styles.preview} />\n            {index !== 0 && (\n              <button onClick={() => changeOrder(index, index - 1)}>up</button>\n            )}\n            {index !== photos.length - 1 && (\n              <button onClick={() => changeOrder(index, index + 1)}>\n                down\n              </button>\n            )}\n            <button onClick={() => remove(index)}>remove</button>\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n\nexport default Previews;\n","function chunkByRows(list, size) {\n  let index = list.length;\n  let result = [];\n\n  while (index > 0) {\n    const startSliceIndex = Math.max(index - size, 0);\n    result.unshift(list.slice(startSliceIndex, index));\n    index -= size;\n  }\n\n  return result;\n}\n\nfunction sliceForTwoPhotos(photos) {\n  if (photos[0].ratio > 1 && photos[1].ratio > 1) {\n    return [[photos[0]], [photos[1]]];\n  }\n\n  return [photos];\n}\n\nfunction sliceForThreePhotos(photos) {\n  if (\n    photos[0].ratio + photos[1].ratio < 2 ||\n    photos[0].ratio + photos[2].ratio < 2 ||\n    photos[1].ratio + photos[2].ratio < 2\n  ) {\n    return [photos];\n  }\n\n  return chunkByRows(photos, 2);\n}\n\nexport default (photos) => {\n  const length = photos.length;\n\n  if (length <= 1) {\n    return [photos];\n  } else if (length === 2) {\n    return sliceForTwoPhotos(photos);\n  } else if (length === 3) {\n    return sliceForThreePhotos(photos);\n  } else if (length === 4) {\n    return chunkByRows(photos, 2);\n  } else {\n    return chunkByRows(photos, 3);\n  }\n};\n","function sumRowRation(list) {\n  let sumRatio = 0;\n  let index = 0;\n\n  while (index < list.length) {\n    sumRatio += list[index].ratio;\n    index++;\n  }\n\n  return sumRatio;\n}\n\nfunction diffSumRowsRatio(list) {\n  let rowsRatioDiff = [];\n  let index = 0;\n\n  while (index < list.length - 1) {\n    rowsRatioDiff.push(list[index] - list[index + 1]);\n    index++;\n  }\n\n  return rowsRatioDiff;\n}\n\nfunction calculateCoefficientForComparison(rowsRatioDiff) {\n  let coeffForComparison = 0;\n  let index = 0;\n\n  while (index < rowsRatioDiff.length) {\n    coeffForComparison += Math.abs(rowsRatioDiff[index]);\n    index++;\n  }\n\n  return coeffForComparison;\n}\n\nexport default (rowsPhotos) => {\n  const summedRowsRation = rowsPhotos.map(sumRowRation);\n  const rowsRatioDiff = diffSumRowsRatio(summedRowsRation);\n  const coeffForComparison = calculateCoefficientForComparison(rowsRatioDiff);\n\n  return {\n    rowsPhotos,\n    rowsRatioDiff,\n    coeffForComparison,\n  };\n};\n","function calculateMaxDiffIndex(rowsRatioDiff) {\n  let maxDiffIndex = 0;\n  let index = 1;\n\n  while (index < rowsRatioDiff.length) {\n    if (\n      Math.abs(rowsRatioDiff[index]) > Math.abs(rowsRatioDiff[maxDiffIndex])\n    ) {\n      maxDiffIndex = index;\n    }\n\n    index++;\n  }\n\n  return maxDiffIndex;\n}\n\nfunction moveImageToPrevRow(index, maxDiffIndex, rowsPhotos) {\n  if (index === maxDiffIndex) {\n    const currentPhotosRow = rowsPhotos[index];\n    const firstPhotoOfNextRow = rowsPhotos[index + 1][0];\n\n    return currentPhotosRow.concat(firstPhotoOfNextRow);\n  }\n\n  // for the case index === maxDiffIndex + 1\n  const currentPhotosRow = rowsPhotos[index];\n\n  return currentPhotosRow.slice(1);\n}\n\nfunction moveImageToNextRow(index, maxDiffIndex, rowsPhotos) {\n  if (index === maxDiffIndex) {\n    const currentPhotosRow = rowsPhotos[index];\n\n    return currentPhotosRow.slice(0, currentPhotosRow.length - 1);\n  }\n\n  // for the case index === maxDiffIndex + 1\n  const prevPhotosRow = rowsPhotos[index - 1];\n  const lastPhotoOfPrevRow = prevPhotosRow[prevPhotosRow.length - 1];\n  const currentPhotosRow = rowsPhotos[index];\n\n  return [lastPhotoOfPrevRow].concat(currentPhotosRow);\n}\n\nfunction moveImageToOtherLine(rowsPhotos, rowsRatioDiff, maxDiffIndex) {\n  const moveMethod =\n    rowsRatioDiff[maxDiffIndex] > 0 ? moveImageToNextRow : moveImageToPrevRow;\n\n  let newRowsPhotos = [];\n\n  for (let index = 0; index < rowsPhotos.length; index++) {\n    if (index === maxDiffIndex || index === maxDiffIndex + 1) {\n      const row = moveMethod(index, maxDiffIndex, rowsPhotos);\n      newRowsPhotos.push(row);\n    } else {\n      newRowsPhotos.push(rowsPhotos[index]);\n    }\n  }\n\n  return newRowsPhotos;\n}\n\nexport default ({ rowsPhotos, rowsRatioDiff }) => {\n  const maxDiffIndex = calculateMaxDiffIndex(rowsRatioDiff);\n\n  return moveImageToOtherLine(rowsPhotos, rowsRatioDiff, maxDiffIndex);\n};\n","const CONTAINER_WIDTH = 440;\n\nfunction sumRatio(rowPhotos) {\n  let sum = 0;\n  let index = 0;\n\n  while (index < rowPhotos.length) {\n    sum += rowPhotos[index].ratio;\n    index++;\n  }\n\n  return sum;\n}\n\nfunction updateSizes(rowPhotos) {\n  const ratioSum = sumRatio(rowPhotos);\n\n  const firstPhoto = rowPhotos[0];\n\n  const widthOfFirstPhoto = Math.floor(\n    (CONTAINER_WIDTH * firstPhoto.ratio) / ratioSum\n  );\n\n  const heightOfFirstPhoto = Math.floor(widthOfFirstPhoto / firstPhoto.ratio);\n\n  let updatedRowPhotos = [\n    {\n      width: widthOfFirstPhoto,\n      height: heightOfFirstPhoto,\n      image: firstPhoto.image,\n    },\n  ];\n\n  let index = 1;\n\n  while (index < rowPhotos.length) {\n    const width = Math.floor(\n      (CONTAINER_WIDTH * rowPhotos[index].ratio) / ratioSum\n    );\n\n    updatedRowPhotos.push({\n      image: rowPhotos[index].image,\n      width,\n      height: heightOfFirstPhoto,\n    });\n\n    index++;\n  }\n\n  return updatedRowPhotos;\n}\n\nexport default (rowsPhotos) => {\n  const newRowsPhotos = [];\n  let index = 0;\n\n  while (index < rowsPhotos.length) {\n    newRowsPhotos.push(updateSizes(rowsPhotos[index]));\n    index++;\n  }\n\n  return newRowsPhotos;\n};\n","import sliceToRows from \"./sliceToRows\";\nimport analyze from \"./analyze\";\nimport shuffle from \"./shuffle\";\nimport updateWidthHeight from \"./updateWidthHeight\";\n\nexport default (photos) => {\n  const rowsPhotos = sliceToRows(photos);\n\n  let data = analyze(rowsPhotos);\n\n  if (rowsPhotos.length > 1) {\n    let tmpData;\n    let shuffledRowsPhotos;\n    let shuffledData;\n\n    while (\n      !shuffledData ||\n      data.coeffForComparison > shuffledData.coeffForComparison\n    ) {\n      tmpData = shuffledData;\n      shuffledRowsPhotos = shuffle(data);\n      shuffledData = analyze(shuffledRowsPhotos);\n\n      if (tmpData) {\n        data = tmpData;\n      }\n    }\n  }\n\n  return updateWidthHeight(data.rowsPhotos);\n};\n","import React, { useState, useEffect } from \"react\";\n\nimport getAlboms from \"./getAlboms\";\nimport styles from \"./styles.module.css\";\n\nfunction removeExtraLayer(albom) {\n  return albom.reduce((memo, item) => {\n    return [...memo, ...item];\n  }, []);\n}\n\nconst Result = ({ photos }) => {\n  const [result, setResult] = useState([]);\n\n  useEffect(() => {\n    const alboms = getAlboms(photos);\n\n    setResult(alboms.map((albom) => removeExtraLayer(albom)));\n  }, [photos]);\n\n  return (\n    <div className={styles.container}>\n      <h2>ALBOMS</h2>\n      {result.map((albom, index) => {\n        return (\n          <div key={index} className={styles.albom}>\n            {albom.map((item, index) => {\n              return (\n                <img\n                  key={index}\n                  width={item.width}\n                  height={item.height}\n                  src={item.image}\n                />\n              );\n            })}\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n\nexport default Result;\n","import convertToRatio from \"./convertToRatio\";\nimport chunk from \"./chunk\";\nimport calculateAlbom from \"./calculateAlbom\";\n\nexport default (photos) => {\n  const photosWithRatio = convertToRatio(photos);\n  const alboms = chunk(photosWithRatio, 9);\n\n  return alboms.map((albom) => calculateAlbom(albom));\n};\n","export default (list, size) => {\n  let index = 0;\n  let result = [];\n\n  while (index < list.length) {\n    result.push(list.slice(index, index + size));\n    index += size;\n  }\n\n  return result;\n};\n","export default (photos) => {\n  return photos.map((photo) => {\n    return {\n      image: photo.image,\n      width: photo.width,\n      height: photo.height,\n      ratio: photo.width / photo.height,\n    };\n  });\n};\n","import React, { useState } from \"react\";\n\nimport Previews from \"../Previews\";\nimport Result from \"../Result\";\nimport styles from \"./styles.module.css\";\n\nfunction handleImage(file) {\n  return new Promise((resolve) => {\n    const reader = new FileReader();\n\n    reader.onloadend = function (event) {\n      const img = new Image();\n\n      img.onload = function () {\n        resolve({\n          id: Math.floor(Math.random() * Math.floor(1000000)),\n          width: this.width,\n          height: this.height,\n          image: event.target.result,\n        });\n      };\n\n      img.src = event.target.result;\n    };\n\n    reader.readAsDataURL(file);\n  });\n}\n\nconst Albom = () => {\n  const [photos, setPhotos] = useState([]);\n\n  const handleChange = async (event) => {\n    const files = event.target.files;\n    const requests = [];\n\n    for (var i = 0; i < files.length; i++) {\n      requests.push(handleImage(files[i]));\n    }\n\n    const results = await Promise.all(requests);\n\n    setPhotos([...photos, ...results]);\n  };\n\n  const changeOrder = (prevIndex, newIndex) => {\n    const newPhotos = photos.reduce((memo, item, index, list) => {\n      if (index === prevIndex) {\n        memo.push(list[newIndex]);\n      } else if (index === newIndex) {\n        memo.push(list[prevIndex]);\n      } else {\n        memo.push(item);\n      }\n\n      return memo;\n    }, []);\n\n    setPhotos(newPhotos);\n  };\n\n  const remove = (removeIndex) => {\n    const newPhotos = photos.filter((item, index) => {\n      return index !== removeIndex;\n    });\n\n    setPhotos(newPhotos);\n  };\n\n  return (\n    <div className={styles.container}>\n      <input type=\"file\" onChange={handleChange} multiple />\n      <div className={styles.imagesContainer}>\n        <Previews photos={photos} changeOrder={changeOrder} remove={remove} />\n        <Result photos={photos} />\n      </div>\n    </div>\n  );\n};\n\nexport default Albom;\n","import React from \"react\";\n\nimport styles from \"./styles.module.css\";\n\nconst Code = () => {\n  return (\n    <div className={styles.container}>\n      <h2>CODE</h2>\n      <i>Входные данные:</i>\n      <pre className={styles.data}>{`\n  const photos = [{\n    width: 220,\n    height: 220,\n    image: \"https://...\"\n  }, {\n    width: 1200,\n    height: 800,\n    image: \"https://...\"\n  }]\n      `}</pre>\n      <br />\n      <b>\n        1) Первый шаг, это посчитать соотношение ширины к высоте картинки\n        (Ratio)\n      </b>\n      <br />\n      <i>Код:</i>\n      <pre className={styles.code}>{`\n  function convertToRatio(photos) {\n    const newPhotos = [];\n    let index = 0;\n\n    while (index < photos.length) {\n      newPhotos.push({\n        width: photo.width,\n        height: photo.height,\n        image: photo.image,\n        ratio: photo.width / photo.height,\n      })\n    }\n\n    return photos;\n  }\n      `}</pre>\n      <i>Данные на выходе:</i>\n      <pre className={styles.data}>{`\n  const photosWithRatio = [{\n    width: 220,\n    height: 220,\n    image: \"https://...\",\n    ratio: 1,\n  }, {\n    width: 1200,\n    height: 800,\n    image: \"https://...\",\n    ratio: 1.5\n  }]\n      `}</pre>\n      <br />\n      <b>\n        2) По требованиям в альбоме максимальное кол-во фото 9,\n        <br />\n        поэтому разобьем фотки на несколько альбомов\n      </b>\n      <br />\n      <i>Код:</i>\n      <pre className={styles.code}>{`\n  const alboms = chunk(photosWithRatio, 9);\n\n  function chunk(list, size) {\n    let index = 0;\n    let result = [];\n  \n    while (index < list.length) {\n      result.push(list.slice(index, index + size));\n      index += size;\n    }\n  \n    return result;\n  };\n      `}</pre>\n      <i>Данные на выходе:</i>\n      <pre className={styles.data}>{`\n  const alboms = [\n    [{}, {}, {}, {}, {}, {}, {}, {}, {}],\n    [{}, {}, {}, {}, {}, {}, {}, {}, {}],\n    [{}, {}, {}, {}],\n  ];\n      `}</pre>\n      <b>\n        3) Далее нужно вычислить каждый альбом в отдельности\n        <br />\n        Саму функцию calculateAlbom рассмотрим ниже\n      </b>\n      <br />\n      <i>Код:</i>\n      <pre className={styles.code}>{`\n  const calculatedAlboms = [];\n  let index = 0;\n\n  while (index < alboms.length) {\n    const calculatedAlbom = calculateAlbom(alboms[index]);\n    calculatedAlboms.push(calculatedAlbom);\n    index++;\n  }\n\n  return calculatedAlboms;\n      `}</pre>\n      <i>Данные на выходе:</i>\n      <pre className={styles.data}>{`\n  const calculatedAlboms = [\n    [ // first albom\n      [{}, {}, {}, {}], // first row of photos\n      [{}, {}] // second row of photos\n      [{}, {}, {}] // third row of photos\n    ], [ // second albom\n      [{}, {}, {}],\n      [{}, {}]\n    ]\n  ];\n\n  // example of photo\n  const albom = {\n    width: 48, // updated width\n    height: 48, // updated height\n    image: \"https://...\"\n  }\n      `}</pre>\n      <b>\n        4) Рассмотрим внутренности calculateAlbom\n        <br />\n        для начала разделим картинки на предположительные ряды\n      </b>\n      <br />\n      <i>Код:</i>\n      <pre className={styles.code}>{`\n  const rowsPhotos = sliceToRows(photos);\n\n  function sliceToRows(photos) {\n    const length = photos.length;\n\n    if (length <= 1) {\n      return [photos];\n    } else if (length === 2) {\n      return sliceForTwoPhotos(photos);\n    } else if (length === 3) {\n      return sliceForThreePhotos(photos);\n    } else if (length === 4) {\n      return chunkByRows(photos, 2);\n    } else {\n      return chunkByRows(photos, 3);\n    }\n  }\n\n  function sliceForTwoPhotos(photos) {\n    if (photos[0].ratio > 1 && photos[1].ratio > 1) {\n      return [[photos[0]], [photos[1]]];\n    }\n  \n    return [photos];\n  }\n\n  function sliceForThreePhotos(photos) {\n    if (\n      photos[0].ratio + photos[1].ratio < 2 ||\n      photos[0].ratio + photos[2].ratio < 2 ||\n      photos[1].ratio + photos[2].ratio < 2\n    ) {\n      return [photos];\n    }\n  \n    return chunkByRows(photos, 2);\n  }\n\n  // chunk in reverse direction\n  function chunkByRows(list, size) {\n    let index = list.length;\n    let result = [];\n  \n    while (index > 0) {\n      const startSliceIndex = Math.max(index - size, 0);\n      result.unshift(list.slice(startSliceIndex, index));\n      index -= size;\n    }\n  \n    return result;\n  }\n      `}</pre>\n      <i>Данные на выходе:</i>\n      <pre className={styles.data}>{`\n      const photos = [{}, {}, {}, {}, {}, {}, {}, {}, {}];\n\n      ->\n      \n      const rowsPhotos = [\n        [{}, {}, {}],\n        [{}, {}, {}],\n        [{}, {}, {}]\n      ]\n      `}</pre>\n      <b>\n        5) Для того чтобы оценить насколько хорошо мы разбили картинки\n        <br />\n        нужно получить какие то данные для сравнения.\n        <br />\n        Поэтому проанализируем текущее разбиение с помощью функции analyze\n      </b>\n      <br />\n      <i>Код:</i>\n      <pre className={styles.code}>{`\n  let data = analyze(rowsPhotos);\n\n  function analyze(rowsPhotos) {\n    // we need to calculate ratio sum of each row \n    const summedRowsRation = sumRowRationForEachRow(rowsPhotos);\n\n    // we need to calculate ratio diff between rows\n    // it helps us to understand the direction for moving photo\n    const rowsRatioDiff = diffSumRowsRatio(summedRowsRation);\n\n    // we need some value for understanding current albom is better or after shufle\n    const coeffForComparison = calculateCoefficientForComparison(rowsRatioDiff);\n\n    return {\n      rowsPhotos,\n      rowsRatioDiff,\n      coeffForComparison,\n    };\n  }\n\n  function sumRowRationForEachRow(rowsPhotos) {\n    let rowsSum = [];\n    let rowIndex = 0;\n\n    while (rowIndex < rowsPhotos.length) {\n      let sum = 0;\n      let photoIndex = 0;\n\n      while (photoIndex < rowsPhotos[rowIndex].length) {\n        sum += rowsPhotos[rowIndex].ration;\n        photoIndex++;\n      }\n\n      rowsSum.push(sum);\n      rowIndex++;\n    }\n\n    return rowsSum;\n  }\n\n  function diffSumRowsRatio(summedRowsRation) {\n    let rowsRatioDiff = [];\n    let index = 0;\n\n    while (index < summedRowsRation.length - 1) {\n      rowsRatioDiff.push(summedRowsRation[index] - summedRowsRation[index + 1]);\n      index++;\n    }\n\n    return rowsRatioDiff;\n  }\n\n  function calculateCoefficientForComparison(rowsRatioDiff) {\n    let coeffForComparison = 0;\n    let index = 0;\n  \n    while (index < rowsRatioDiff.length) {\n      coeffForComparison += Math.abs(rowsRatioDiff[index]);\n      index++;\n    }\n  \n    return coeffForComparison;\n  }\n      `}</pre>\n      <i>Данные на выходе:</i>\n      <pre className={styles.data}>{`\n  const rowsPhotos = [\n    [{}, {}, {}],\n    [{}, {}, {}],\n    [{}, {}, {}]\n  ]\n\n  ->\n\n  const data = {\n    rowsPhotos: [[{}, {}, {}], [{}, {}, {}], [{}, {}, {}]]\n    rowsRatioDiff: [0.6537, -0.4366]\n    coeffForComparison; 1.0903,\n  };\n      `}</pre>\n      <b>\n        6) Далее нужно попытаться перемешать картинки\n        <br />\n        И попытаться проанализировать перемешанные картинки\n        <br />И так мешать пока перемешанные данные не будут хуже предыдущей\n      </b>\n      <br />\n      <i>Код:</i>\n      <pre className={styles.code}>{`\n  let data = analyze(rowsPhotos);\n  let tmpData;\n  let shuffledRowsPhotos;\n  let shuffledData;\n\n  while (\n    !shuffledData ||\n    data.coeffForComparison > shuffledData.coeffForComparison\n  ) {\n    tmpData = shuffledData;\n    shuffledRowsPhotos = shuffle(data);\n    shuffledData = analyze(shuffledRowsPhotos);\n\n    if (tmpData) {\n      data = tmpData;\n    }\n  }\n\n  console.log(data); // the best solution\n      `}</pre>\n      <b>\n        7) Изучим как работает shuffle\n        <br />\n        Основная идея, это по разности между суммой Ration,\n        <br />\n        переносить одну картинку либо на следующую строку либо на предыдушую\n      </b>\n      <br />\n      <i>Код:</i>\n      <pre className={styles.code}>{`\n  let shuffledRowsPhotos = shuffle(data);\n\n  function shuffle({ rowsPhotos, rowsRatioDiff }) {\n    const maxDiffIndex = calculateMaxDiffIndex(rowsRatioDiff);\n\n    return moveImageToOtherLine(rowsPhotos, rowsRatioDiff, maxDiffIndex);\n  }\n\n  function calculateMaxDiffIndex(rowsRatioDiff) {\n    let maxDiffIndex = 0;\n    let index = 1;\n  \n    while (index < rowsRatioDiff.length) {\n      if (\n        Math.abs(rowsRatioDiff[index]) > Math.abs(rowsRatioDiff[maxDiffIndex])\n      ) {\n        maxDiffIndex = index;\n      }\n  \n      index++;\n    }\n  \n    return maxDiffIndex;\n  }\n\n  function moveImageToOtherLine(rowsPhotos, rowsRatioDiff, maxDiffIndex) {\n\n    // see below implementation moveImageToNextRow and moveImageToPrevRow\n    const moveMethod = rowsRatioDiff[maxDiffIndex] > 0 ? moveImageToNextRow : moveImageToPrevRow;\n  \n    let newRowsPhotos = [];\n  \n    for (let index = 0; index < rowsPhotos.length; index++) {\n      if (index === maxDiffIndex || index === maxDiffIndex + 1) {\n        const row = moveMethod(index, maxDiffIndex, rowsPhotos);\n        newRowsPhotos.push(row);\n      } else {\n        newRowsPhotos.push(rowsPhotos[index]);\n      }\n    }\n  \n    return newRowsPhotos;\n  }\n\n  function moveImageToPrevRow(index, maxDiffIndex, rowsPhotos) {\n    if (index === maxDiffIndex) {\n      const currentPhotosRow = rowsPhotos[index];\n      const firstPhotoOfNextRow = rowsPhotos[index + 1][0];\n  \n      return currentPhotosRow.concat(firstPhotoOfNextRow);\n    }\n  \n    // for the case index === maxDiffIndex + 1\n    const currentPhotosRow = rowsPhotos[index];\n  \n    return currentPhotosRow.slice(1);\n  }\n  \n  function moveImageToNextRow(index, maxDiffIndex, rowsPhotos) {\n    if (index === maxDiffIndex) {\n      const currentPhotosRow = rowsPhotos[index];\n  \n      return currentPhotosRow.slice(0, currentPhotosRow.length - 1);\n    }\n  \n    // for the case index === maxDiffIndex + 1\n    const prevPhotosRow = rowsPhotos[index - 1];\n    const lastPhotoOfPrevRow = prevPhotosRow[prevPhotosRow.length - 1];\n    const currentPhotosRow = rowsPhotos[index];\n  \n    return [lastPhotoOfPrevRow].concat(currentPhotosRow);\n  }\n      `}</pre>\n      <i>Данные на выходе:</i>\n      <pre className={styles.data}>{`\n  const photosBefore = [\n    [{}, {}, {}],\n    [{}, {}, {}],\n    [{}, {}, {}]\n  ]\n\n  ->\n\n  const photosAfter = [\n    [{}, {}],\n    [{}, {}, {}, {}],\n    [{}, {}, {}]\n  ]\n      `}</pre>\n      <b>\n        8) После распределения картинок по рядам,\n        <br />\n        нам нужно вычесть новые размеры картинок при размере бабла 300px\n      </b>\n      <br />\n      <i>Код:</i>\n      <pre className={styles.code}>{`\n  const CONTAINER_WIDTH = 300; // size of bubble\n\n  const updatedRowsPhotos = updateWidthHeight(data.rowsPhotos)\n\n  function updateWidthHeight(rowsPhotos) {\n    const newRowsPhotos = [];\n    let index = 0;\n  \n    while (index < rowsPhotos.length) {\n      newRowsPhotos.push(updateSizes(rowsPhotos[index]));\n      index++;\n    }\n  \n    return newRowsPhotos;\n  }\n\n  function updateSizes(rowPhotos) {\n    const ratioSum = sumRatio(rowPhotos);\n  \n    const firstPhoto = rowPhotos[0];\n  \n    const widthOfFirstPhoto = Math.floor(\n      (CONTAINER_WIDTH * firstPhoto.ratio) / ratioSum\n    );\n  \n    const heightOfFirstPhoto = Math.floor(widthOfFirstPhoto / firstPhoto.ratio);\n  \n    let updatedRowPhotos = [\n      {\n        width: widthOfFirstPhoto,\n        height: heightOfFirstPhoto,\n        image: firstPhoto.image,\n      },\n    ];\n  \n    let index = 1;\n  \n    while (index < rowPhotos.length) {\n      const width = Math.floor(\n        (CONTAINER_WIDTH * rowPhotos[index].ratio) / ratioSum\n      );\n  \n      updatedRowPhotos.push({\n        image: rowPhotos[index].image,\n        width,\n        height: heightOfFirstPhoto,\n      });\n  \n      index++;\n    }\n  \n    return updatedRowPhotos;\n  }\n\n  function sumRatio(rowPhotos) {\n    let sum = 0;\n    let index = 0;\n  \n    while (index < rowPhotos.length) {\n      sum += rowPhotos[index].ratio;\n      index++;\n    }\n  \n    return sum;\n  }\n      `}</pre>\n    </div>\n  );\n};\n\nexport default Code;\n","import React from \"react\";\n\nimport Albom from \"../Albom\";\nimport Code from \"../Code\";\n\nconst App = () => {\n  return (\n    <>\n      <Albom />\n      <hr />\n      <Code />\n    </>\n  );\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"styles_container__qb2Av\",\"preview\":\"styles_preview__3hwAV\"};"],"sourceRoot":""}