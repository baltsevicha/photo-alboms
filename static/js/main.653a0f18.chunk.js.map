{"version":3,"sources":["components/Code/styles.module.css","components/Result/styles.module.css","components/Albom/styles.module.css","components/Previews/index.js","components/Result/getAlboms/chunk.js","components/Result/getAlboms/calculateAlbom/analyze.js","components/Result/getAlboms/calculateAlbom/shuffle.js","components/Result/getAlboms/calculateAlbom/updateWidthHeight.js","components/Result/getAlboms/calculateAlbom/index.js","components/Result/getAlboms/calculateAlbom/sliceToRows.js","components/Result/index.js","components/Result/getAlboms/index.js","components/Result/getAlboms/convertToRatio.js","components/Albom/index.jsx","components/Code/index.js","components/App/index.jsx","index.js","components/Previews/styles.module.css"],"names":["module","exports","Previews","photos","changeOrder","remove","map","photo","index","className","styles","container","src","image","preview","onClick","length","id","list","size","result","push","slice","sumRowRation","sumRatio","ratio","rowsPhotos","rowsRatioDiff","diffSumRowsRatio","coeffForComparison","Math","abs","calculateCoefficientForComparison","moveImageToPrevRow","maxDiffIndex","currentPhotosRow","firstPhotoOfNextRow","concat","moveImageToNextRow","prevPhotosRow","lastPhotoOfPrevRow","moveMethod","newRowsPhotos","row","moveImageToOtherLine","calculateMaxDiffIndex","updateSizes","rowPhotos","ratioSum","sum","firstPhoto","widthOfFirstPhoto","floor","heightOfFirstPhoto","updatedRowPhotos","width","height","sliceForTwoPhotos","chunk","sliceToRows","data","analyze","tmpData","shuffledRowsPhotos","shuffledData","shuffle","updateWidthHeight","Result","useState","setResult","useEffect","alboms","photosWithRatio","convertToRatio","albom","calculateAlbom","getAlboms","reduce","memo","item","removeExtraLayer","handleImage","file","Promise","resolve","reader","FileReader","onloadend","event","img","Image","onload","random","this","target","readAsDataURL","Albom","setPhotos","handleChange","a","files","requests","i","all","results","type","onChange","multiple","imagesContainer","prevIndex","newIndex","newPhotos","removeIndex","filter","Code","code","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.653a0f18.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"styles_container__zQDVE\",\"data\":\"styles_data__ct4jE\",\"code\":\"styles_code__n3hbZ\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"albom\":\"styles_albom__2EzAS\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"styles_container__39iyr\",\"imagesContainer\":\"styles_imagesContainer__ot1b5\"};","import React from \"react\";\n\nimport styles from \"./styles.module.css\";\n\nconst Previews = ({ photos, changeOrder, remove }) => {\n  return (\n    <div>\n      {photos.map((photo, index) => {\n        return (\n          <div key={photo.id} className={styles.container}>\n            <img src={photo.image} className={styles.preview} />\n            {index !== 0 && (\n              <button onClick={() => changeOrder(index, index - 1)}>up</button>\n            )}\n            {index !== photos.length - 1 && (\n              <button onClick={() => changeOrder(index, index + 1)}>\n                down\n              </button>\n            )}\n            <button onClick={() => remove(index)}>remove</button>\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n\nexport default Previews;\n","export default (list, size) => {\n  let index = 0;\n  let result = [];\n\n  while (index < list.length) {\n    result.push(list.slice(index, index + size));\n    index += size;\n  }\n\n  return result;\n};\n","function sumRowRation(list) {\n  let sumRatio = 0;\n  let index = 0;\n\n  while (index < list.length) {\n    sumRatio += list[index].ratio;\n    index++;\n  }\n\n  return sumRatio;\n}\n\nfunction diffSumRowsRatio(list) {\n  let rowsRatioDiff = [];\n  let index = 0;\n\n  while (index < list.length - 1) {\n    rowsRatioDiff.push(list[index] - list[index + 1]);\n    index++;\n  }\n\n  return rowsRatioDiff;\n}\n\nfunction calculateCoefficientForComparison(rowsRatioDiff) {\n  let coeffForComparison = 0;\n  let index = 0;\n\n  while (index < rowsRatioDiff.length) {\n    coeffForComparison += Math.abs(rowsRatioDiff[index]);\n    index++;\n  }\n\n  return coeffForComparison;\n}\n\nexport default (rowsPhotos) => {\n  const summedRowsRation = rowsPhotos.map(sumRowRation);\n  const rowsRatioDiff = diffSumRowsRatio(summedRowsRation);\n  const coeffForComparison = calculateCoefficientForComparison(rowsRatioDiff);\n\n  return {\n    rowsPhotos,\n    rowsRatioDiff,\n    coeffForComparison,\n  };\n};\n","function calculateMaxDiffIndex(rowsRatioDiff) {\n  let maxDiffIndex = 0;\n  let index = 1;\n\n  while (index < rowsRatioDiff.length) {\n    if (\n      Math.abs(rowsRatioDiff[index]) > Math.abs(rowsRatioDiff[maxDiffIndex])\n    ) {\n      maxDiffIndex = index;\n    }\n\n    index++;\n  }\n\n  return maxDiffIndex;\n}\n\nfunction moveImageToPrevRow(index, maxDiffIndex, rowsPhotos) {\n  if (index === maxDiffIndex) {\n    const currentPhotosRow = rowsPhotos[index];\n    const firstPhotoOfNextRow = rowsPhotos[index + 1][0];\n\n    return currentPhotosRow.concat(firstPhotoOfNextRow);\n  }\n\n  // for the case index === maxDiffIndex + 1\n  const currentPhotosRow = rowsPhotos[index];\n\n  return currentPhotosRow.slice(1);\n}\n\nfunction moveImageToNextRow(index, maxDiffIndex, rowsPhotos) {\n  if (index === maxDiffIndex) {\n    const currentPhotosRow = rowsPhotos[index];\n\n    return currentPhotosRow.slice(0, currentPhotosRow.length - 1);\n  }\n\n  // for the case index === maxDiffIndex + 1\n  const prevPhotosRow = rowsPhotos[index - 1];\n  const lastPhotoOfPrevRow = prevPhotosRow[prevPhotosRow.length - 1];\n  const currentPhotosRow = rowsPhotos[index];\n\n  return [lastPhotoOfPrevRow].concat(currentPhotosRow);\n}\n\nfunction moveImageToOtherLine(rowsPhotos, rowsRatioDiff, maxDiffIndex) {\n  const moveMethod =\n    rowsRatioDiff[maxDiffIndex] > 0 ? moveImageToNextRow : moveImageToPrevRow;\n\n  let newRowsPhotos = [];\n\n  for (let index = 0; index < rowsPhotos.length; index++) {\n    if (index === maxDiffIndex || index === maxDiffIndex + 1) {\n      const row = moveMethod(index, maxDiffIndex, rowsPhotos);\n      newRowsPhotos.push(row);\n    } else {\n      newRowsPhotos.push(rowsPhotos[index]);\n    }\n  }\n\n  return newRowsPhotos;\n}\n\nexport default ({ rowsPhotos, rowsRatioDiff }) => {\n  const maxDiffIndex = calculateMaxDiffIndex(rowsRatioDiff);\n\n  return moveImageToOtherLine(rowsPhotos, rowsRatioDiff, maxDiffIndex);\n};\n","const CONTAINER_WIDTH = 300;\n\nfunction sumRatio(rowPhotos) {\n  let sum = 0;\n  let index = 0;\n\n  while (index < rowPhotos.length) {\n    sum += rowPhotos[index].ratio;\n    index++;\n  }\n\n  return sum;\n}\n\nfunction updateSizes(rowPhotos) {\n  const ratioSum = sumRatio(rowPhotos);\n\n  const firstPhoto = rowPhotos[0];\n\n  const widthOfFirstPhoto = Math.floor(\n    (CONTAINER_WIDTH * firstPhoto.ratio) / ratioSum\n  );\n\n  const heightOfFirstPhoto = Math.floor(widthOfFirstPhoto / firstPhoto.ratio);\n\n  let updatedRowPhotos = [\n    {\n      width: widthOfFirstPhoto,\n      height: heightOfFirstPhoto,\n      image: firstPhoto.image,\n    },\n  ];\n\n  let index = 1;\n\n  while (index < rowPhotos.length) {\n    const width = Math.floor(\n      (CONTAINER_WIDTH * rowPhotos[index].ratio) / ratioSum\n    );\n\n    updatedRowPhotos.push({\n      image: rowPhotos[index].image,\n      width,\n      height: heightOfFirstPhoto,\n    });\n\n    index++;\n  }\n\n  return updatedRowPhotos;\n}\n\nexport default (rowsPhotos) => {\n  const newRowsPhotos = [];\n  let index = 0;\n\n  while (index < rowsPhotos.length) {\n    newRowsPhotos.push(updateSizes(rowsPhotos[index]));\n    index++;\n  }\n\n  return newRowsPhotos;\n};\n","import sliceToRows from \"./sliceToRows\";\nimport analyze from \"./analyze\";\nimport shuffle from \"./shuffle\";\nimport updateWidthHeight from \"./updateWidthHeight\";\n\nexport default (photos) => {\n  const rowsPhotos = sliceToRows(photos);\n\n  let data = analyze(rowsPhotos);\n\n  if (rowsPhotos.length > 1) {\n    let tmpData;\n    let shuffledRowsPhotos;\n    let shuffledData;\n\n    while (\n      !shuffledData ||\n      data.coeffForComparison > shuffledData.coeffForComparison\n    ) {\n      tmpData = shuffledData;\n      shuffledRowsPhotos = shuffle(data);\n      shuffledData = analyze(shuffledRowsPhotos);\n\n      if (tmpData) {\n        data = tmpData;\n      }\n    }\n  }\n\n  return updateWidthHeight(data.rowsPhotos);\n};\n","import chunk from \"../chunk\";\n\nfunction sliceForTwoPhotos(photos) {\n  const sumRation = photos[0].ratio + photos[1].ratio;\n\n  if (sumRation <= 2) {\n    return [photos];\n  }\n\n  return [[photos[0]], [photos[1]]];\n}\n\nexport default (photos) => {\n  const length = photos.length;\n\n  if (length <= 1) {\n    return [photos];\n  } else if (length === 2) {\n    return sliceForTwoPhotos(photos);\n  } else if (length <= 4) {\n    return chunk(photos, 2);\n  } else {\n    return chunk(photos, 3);\n  }\n};\n","import React, { useState, useEffect } from \"react\";\n\nimport getAlboms from \"./getAlboms\";\nimport styles from \"./styles.module.css\";\n\nfunction removeExtraLayer(albom) {\n  return albom.reduce((memo, item) => {\n    return [...memo, ...item];\n  }, []);\n}\n\nconst Result = ({ photos }) => {\n  const [result, setResult] = useState([]);\n\n  useEffect(() => {\n    const alboms = getAlboms(photos);\n\n    setResult(alboms.map((albom) => removeExtraLayer(albom)));\n  }, [photos]);\n\n  return (\n    <div className={styles.container}>\n      <h2>ALBOMS</h2>\n      {result.map((albom, index) => {\n        return (\n          <div key={index} className={styles.albom}>\n            {albom.map((item, index) => {\n              return (\n                <img\n                  key={index}\n                  width={item.width}\n                  height={item.height}\n                  src={item.image}\n                />\n              );\n            })}\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n\nexport default Result;\n","import convertToRatio from \"./convertToRatio\";\nimport chunk from \"./chunk\";\nimport calculateAlbom from \"./calculateAlbom\";\n\nexport default (photos) => {\n  const photosWithRatio = convertToRatio(photos);\n  const alboms = chunk(photosWithRatio, 9);\n\n  return alboms.map((albom) => calculateAlbom(albom));\n};\n","export default (photos) => {\n  return photos.map((photo) => {\n    return {\n      image: photo.image,\n      width: photo.width,\n      height: photo.height,\n      ratio: photo.width / photo.height,\n    };\n  });\n};\n","import React, { useState } from \"react\";\n\nimport Previews from \"../Previews\";\nimport Result from \"../Result\";\nimport styles from \"./styles.module.css\";\n\nfunction handleImage(file) {\n  return new Promise((resolve) => {\n    const reader = new FileReader();\n\n    reader.onloadend = function (event) {\n      const img = new Image();\n\n      img.onload = function () {\n        resolve({\n          id: Math.floor(Math.random() * Math.floor(1000000)),\n          width: this.width,\n          height: this.height,\n          image: event.target.result,\n        });\n      };\n\n      img.src = event.target.result;\n    };\n\n    reader.readAsDataURL(file);\n  });\n}\n\nconst Albom = () => {\n  const [photos, setPhotos] = useState([]);\n\n  const handleChange = async (event) => {\n    const files = event.target.files;\n    const requests = [];\n\n    for (var i = 0; i < files.length; i++) {\n      requests.push(handleImage(files[i]));\n    }\n\n    const results = await Promise.all(requests);\n\n    setPhotos([...photos, ...results]);\n  };\n\n  const changeOrder = (prevIndex, newIndex) => {\n    const newPhotos = photos.reduce((memo, item, index, list) => {\n      if (index === prevIndex) {\n        memo.push(list[newIndex]);\n      } else if (index === newIndex) {\n        memo.push(list[prevIndex]);\n      } else {\n        memo.push(item);\n      }\n\n      return memo;\n    }, []);\n\n    setPhotos(newPhotos);\n  };\n\n  const remove = (removeIndex) => {\n    const newPhotos = photos.filter((item, index) => {\n      return index !== removeIndex;\n    });\n\n    setPhotos(newPhotos);\n  };\n\n  return (\n    <div className={styles.container}>\n      <input type=\"file\" onChange={handleChange} multiple />\n      <div className={styles.imagesContainer}>\n        <Previews photos={photos} changeOrder={changeOrder} remove={remove} />\n        <Result photos={photos} />\n      </div>\n    </div>\n  );\n};\n\nexport default Albom;\n","import React from \"react\";\n\nimport styles from \"./styles.module.css\";\n\nconst Code = () => {\n  return (\n    <div className={styles.container}>\n      <h2>CODE</h2>\n      <i>Входные данные:</i>\n      <pre className={styles.data}>{`\n  const photos = [{\n    width: 220,\n    height: 220,\n    image: \"https://...\"\n  }, {\n    width: 1200,\n    height: 800,\n    image: \"https://...\"\n  }]\n      `}</pre>\n      <br />\n      <b>\n        1) Первый шаг, это посчитать соотношение ширины к высоте картинки\n        (Ratio)\n      </b>\n      <br />\n      <i>Код:</i>\n      <pre className={styles.code}>{`\n  function convertToRatio(photos) {\n    const newPhotos = [];\n    let index = 0;\n\n    while (index < photos.length) {\n      newPhotos.push({\n        width: photo.width,\n        height: photo.height,\n        image: photo.image,\n        ratio: photo.width / photo.height,\n      })\n    }\n\n    return photos;\n  }\n      `}</pre>\n      <i>Данные на выходе:</i>\n      <pre className={styles.data}>{`\n  const photosWithRatio = [{\n    width: 220,\n    height: 220,\n    image: \"https://...\",\n    ratio: 1,\n  }, {\n    width: 1200,\n    height: 800,\n    image: \"https://...\",\n    ratio: 1.5\n  }]\n      `}</pre>\n      <br />\n      <b>\n        2) По требованиям в альбоме максимальное кол-во фото 9,\n        <br />\n        поэтому разобьем фотки на несколько альбомов\n      </b>\n      <br />\n      <i>Код:</i>\n      <pre className={styles.code}>{`\n  const alboms = chunk(photosWithRatio, 9);\n\n  function chunk(list, size) {\n    let index = 0;\n    let result = [];\n  \n    while (index < list.length) {\n      result.push(list.slice(index, index + size));\n      index += size;\n    }\n  \n    return result;\n  };\n      `}</pre>\n      <i>Данные на выходе:</i>\n      <pre className={styles.data}>{`\n  const alboms = [\n    [{}, {}, {}, {}, {}, {}, {}, {}, {}],\n    [{}, {}, {}, {}, {}, {}, {}, {}, {}],\n    [{}, {}, {}, {}],\n  ];\n      `}</pre>\n      <b>\n        3) Далее нужно вычислить каждый альбом в отдельности\n        <br />\n        Саму функцию calculateAlbom рассмотрим ниже\n      </b>\n      <br />\n      <i>Код:</i>\n      <pre className={styles.code}>{`\n  const calculatedAlboms = [];\n  let index = 0;\n\n  while (index < alboms.length) {\n    const calculatedAlbom = calculateAlbom(alboms[index]);\n    calculatedAlboms.push(calculatedAlbom);\n    index++;\n  }\n\n  return calculatedAlboms;\n      `}</pre>\n      <i>Данные на выходе:</i>\n      <pre className={styles.data}>{`\n  const calculatedAlboms = [\n    [ // first albom\n      [{}, {}, {}, {}], // first row of photos\n      [{}, {}] // second row of photos\n      [{}, {}, {}] // third row of photos\n    ], [ // second albom\n      [{}, {}, {}],\n      [{}, {}]\n    ]\n  ];\n\n  // example of photo\n  const albom = {\n    width: 48, // updated width\n    height: 48, // updated height\n    image: \"https://...\"\n  }\n      `}</pre>\n      <b>\n        4) Рассмотрим внутренности calculateAlbom\n        <br />\n        для начала разделим картинки на предположительные ряды\n      </b>\n      <br />\n      <i>Код:</i>\n      <pre className={styles.code}>{`\n  const rowsPhotos = sliceToRows(photos);\n\n  function sliceToRows(photos) {\n    const length = photos.length;\n\n    if (length <= 1) {\n      return [photos];\n    } else if (length === 2) {\n      return sliceForTwoPhotos(photos);\n    } else if (length <= 4) {\n      return chunk(photos, 2); // implementation of chunk see below\n    } else {\n      return chunk(photos, 3);\n    }\n  }\n\n  function sliceForTwoPhotos(photos) {\n    const rationSum = photos[0].ratio + photos[1].ratio;\n  \n    if (rationSum <= 2) {\n      return [photos];\n    }\n  \n    return [[photos[0]], [photos[1]]];\n  }\n      `}</pre>\n      <i>Данные на выходе:</i>\n      <pre className={styles.data}>{`\n      const photos = [{}, {}, {}, {}, {}, {}, {}, {}, {}];\n\n      ->\n      \n      const rowsPhotos = [\n        [{}, {}, {}],\n        [{}, {}, {}],\n        [{}, {}, {}]\n      ]\n      `}</pre>\n      <b>\n        5) Для того чтобы оценить насколько хорошо мы разбили картинки\n        <br />\n        нужно получить какие то данные для сравнения.\n        <br />\n        Поэтому проанализируем текущее разбиение с помощью функции analyze\n      </b>\n      <br />\n      <i>Код:</i>\n      <pre className={styles.code}>{`\n  let data = analyze(rowsPhotos);\n\n  function analyze(rowsPhotos) {\n    // we need to calculate ratio sum of each row \n    const summedRowsRation = sumRowRationForEachRow(rowsPhotos);\n\n    // we need to calculate ratio diff between rows\n    // it helps us to understand the direction for moving photo\n    const rowsRatioDiff = diffSumRowsRatio(summedRowsRation);\n\n    // we need some value for understanding current albom is better or after shufle\n    const coeffForComparison = calculateCoefficientForComparison(rowsRatioDiff);\n\n    return {\n      rowsPhotos,\n      rowsRatioDiff,\n      coeffForComparison,\n    };\n  }\n\n  function sumRowRationForEachRow(rowsPhotos) {\n    let rowsSum = [];\n    let rowIndex = 0;\n\n    while (rowIndex < rowsPhotos.length) {\n      let sum = 0;\n      let photoIndex = 0;\n\n      while (photoIndex < rowsPhotos[rowIndex].length) {\n        sum += rowsPhotos[rowIndex].ration;\n        photoIndex++;\n      }\n\n      rowsSum.push(sum);\n      rowIndex++;\n    }\n\n    return rowsSum;\n  }\n\n  function diffSumRowsRatio(summedRowsRation) {\n    let rowsRatioDiff = [];\n    let index = 0;\n\n    while (index < summedRowsRation.length - 1) {\n      rowsRatioDiff.push(summedRowsRation[index] - summedRowsRation[index + 1]);\n      index++;\n    }\n\n    return rowsRatioDiff;\n  }\n\n  function calculateCoefficientForComparison(rowsRatioDiff) {\n    let coeffForComparison = 0;\n    let index = 0;\n  \n    while (index < rowsRatioDiff.length) {\n      coeffForComparison += Math.abs(rowsRatioDiff[index]);\n      index++;\n    }\n  \n    return coeffForComparison;\n  }\n      `}</pre>\n      <i>Данные на выходе:</i>\n      <pre className={styles.data}>{`\n  const rowsPhotos = [\n    [{}, {}, {}],\n    [{}, {}, {}],\n    [{}, {}, {}]\n  ]\n\n  ->\n\n  const data = {\n    rowsPhotos: [[{}, {}, {}], [{}, {}, {}], [{}, {}, {}]]\n    rowsRatioDiff: [0.6537, -0.4366]\n    coeffForComparison; 1.0903,\n  };\n      `}</pre>\n      <b>\n        6) Далее нужно попытаться перемешать картинки\n        <br />\n        И попытаться проанализировать перемешанные картинки\n        <br />И так мешать пока перемешанные данные не будут хуже предыдущей\n      </b>\n      <br />\n      <i>Код:</i>\n      <pre className={styles.code}>{`\n  let data = analyze(rowsPhotos);\n  let tmpData;\n  let shuffledRowsPhotos;\n  let shuffledData;\n\n  while (\n    !shuffledData ||\n    data.coeffForComparison > shuffledData.coeffForComparison\n  ) {\n    tmpData = shuffledData;\n    shuffledRowsPhotos = shuffle(data);\n    shuffledData = analyze(shuffledRowsPhotos);\n\n    if (tmpData) {\n      data = tmpData;\n    }\n  }\n\n  console.log(data); // the best solution\n      `}</pre>\n      <b>\n        7) Изучим как работает shuffle\n        <br />\n        Основная идея, это по разности между суммой Ration,\n        <br />\n        переносить одну картинку либо на следующую строку либо на предыдушую\n      </b>\n      <br />\n      <i>Код:</i>\n      <pre className={styles.code}>{`\n  let shuffledRowsPhotos = shuffle(data);\n\n  function shuffle({ rowsPhotos, rowsRatioDiff }) {\n    const maxDiffIndex = calculateMaxDiffIndex(rowsRatioDiff);\n\n    return moveImageToOtherLine(rowsPhotos, rowsRatioDiff, maxDiffIndex);\n  }\n\n  function calculateMaxDiffIndex(rowsRatioDiff) {\n    let maxDiffIndex = 0;\n    let index = 1;\n  \n    while (index < rowsRatioDiff.length) {\n      if (\n        Math.abs(rowsRatioDiff[index]) > Math.abs(rowsRatioDiff[maxDiffIndex])\n      ) {\n        maxDiffIndex = index;\n      }\n  \n      index++;\n    }\n  \n    return maxDiffIndex;\n  }\n\n  function moveImageToOtherLine(rowsPhotos, rowsRatioDiff, maxDiffIndex) {\n\n    // see below implementation moveImageToNextRow and moveImageToPrevRow\n    const moveMethod = rowsRatioDiff[maxDiffIndex] > 0 ? moveImageToNextRow : moveImageToPrevRow;\n  \n    let newRowsPhotos = [];\n  \n    for (let index = 0; index < rowsPhotos.length; index++) {\n      if (index === maxDiffIndex || index === maxDiffIndex + 1) {\n        const row = moveMethod(index, maxDiffIndex, rowsPhotos);\n        newRowsPhotos.push(row);\n      } else {\n        newRowsPhotos.push(rowsPhotos[index]);\n      }\n    }\n  \n    return newRowsPhotos;\n  }\n\n  function moveImageToPrevRow(index, maxDiffIndex, rowsPhotos) {\n    if (index === maxDiffIndex) {\n      const currentPhotosRow = rowsPhotos[index];\n      const firstPhotoOfNextRow = rowsPhotos[index + 1][0];\n  \n      return currentPhotosRow.concat(firstPhotoOfNextRow);\n    }\n  \n    // for the case index === maxDiffIndex + 1\n    const currentPhotosRow = rowsPhotos[index];\n  \n    return currentPhotosRow.slice(1);\n  }\n  \n  function moveImageToNextRow(index, maxDiffIndex, rowsPhotos) {\n    if (index === maxDiffIndex) {\n      const currentPhotosRow = rowsPhotos[index];\n  \n      return currentPhotosRow.slice(0, currentPhotosRow.length - 1);\n    }\n  \n    // for the case index === maxDiffIndex + 1\n    const prevPhotosRow = rowsPhotos[index - 1];\n    const lastPhotoOfPrevRow = prevPhotosRow[prevPhotosRow.length - 1];\n    const currentPhotosRow = rowsPhotos[index];\n  \n    return [lastPhotoOfPrevRow].concat(currentPhotosRow);\n  }\n      `}</pre>\n      <i>Данные на выходе:</i>\n      <pre className={styles.data}>{`\n  const photosBefore = [\n    [{}, {}, {}],\n    [{}, {}, {}],\n    [{}, {}, {}]\n  ]\n\n  ->\n\n  const photosAfter = [\n    [{}, {}],\n    [{}, {}, {}, {}],\n    [{}, {}, {}]\n  ]\n      `}</pre>\n      <b>\n        8) После распределения картинок по рядам,\n        <br />\n        нам нужно вычесть новые размеры картинок при размере бабла 300px\n      </b>\n      <br />\n      <i>Код:</i>\n      <pre className={styles.code}>{`\n  const CONTAINER_WIDTH = 300; // size of bubble\n\n  const updatedRowsPhotos = updateWidthHeight(data.rowsPhotos)\n\n  function updateWidthHeight(rowsPhotos) {\n    const newRowsPhotos = [];\n    let index = 0;\n  \n    while (index < rowsPhotos.length) {\n      newRowsPhotos.push(updateSizes(rowsPhotos[index]));\n      index++;\n    }\n  \n    return newRowsPhotos;\n  }\n\n  function updateSizes(rowPhotos) {\n    const ratioSum = sumRatio(rowPhotos);\n  \n    const firstPhoto = rowPhotos[0];\n  \n    const widthOfFirstPhoto = Math.floor(\n      (CONTAINER_WIDTH * firstPhoto.ratio) / ratioSum\n    );\n  \n    const heightOfFirstPhoto = Math.floor(widthOfFirstPhoto / firstPhoto.ratio);\n  \n    let updatedRowPhotos = [\n      {\n        width: widthOfFirstPhoto,\n        height: heightOfFirstPhoto,\n        image: firstPhoto.image,\n      },\n    ];\n  \n    let index = 1;\n  \n    while (index < rowPhotos.length) {\n      const width = Math.floor(\n        (CONTAINER_WIDTH * rowPhotos[index].ratio) / ratioSum\n      );\n  \n      updatedRowPhotos.push({\n        image: rowPhotos[index].image,\n        width,\n        height: heightOfFirstPhoto,\n      });\n  \n      index++;\n    }\n  \n    return updatedRowPhotos;\n  }\n\n  function sumRatio(rowPhotos) {\n    let sum = 0;\n    let index = 0;\n  \n    while (index < rowPhotos.length) {\n      sum += rowPhotos[index].ratio;\n      index++;\n    }\n  \n    return sum;\n  }\n      `}</pre>\n    </div>\n  );\n};\n\nexport default Code;\n","import React from \"react\";\n\nimport Albom from \"../Albom\";\nimport Code from \"../Code\";\n\nconst App = () => {\n  return (\n    <>\n      <Albom />\n      <hr />\n      <Code />\n    </>\n  );\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"styles_container__qb2Av\",\"preview\":\"styles_preview__3hwAV\"};"],"sourceRoot":""}